"use strict";(globalThis.webpackChunkcg_notes=globalThis.webpackChunkcg_notes||[]).push([[34],{2727:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>t,contentTitle:()=>s,default:()=>g,frontMatter:()=>a,metadata:()=>l,toc:()=>c});const l=JSON.parse('{"id":"Programmable_Pipeline","title":"OpenGL Programmable Pipeline","description":"Covers Section 10 + Lab 3 (WebGL 2.0)","source":"@site/docs/Programmable_Pipeline.md","sourceDirName":".","slug":"/Programmable_Pipeline","permalink":"/cvg-notes/docs/Programmable_Pipeline","draft":false,"unlisted":false,"editUrl":"https://github.com/tino-ryan/cvg-notes/tree/main/docs/Programmable_Pipeline.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"OpenGL Basics","permalink":"/cvg-notes/docs/OpenGL_Basics"},"next":{"title":"OpenGL Textures & WebGL Shaders","permalink":"/cvg-notes/docs/Textures"}}');var i=r(4848),o=r(8453);const a={},s="OpenGL Programmable Pipeline",t={},c=[{value:"1. Programmable Pipeline Overview (Section 10)",id:"1-programmable-pipeline-overview-section-10",level:2},{value:"2. Shader Basics",id:"2-shader-basics",level:2},{value:"2.1 Vertex Shader",id:"21-vertex-shader",level:3},{value:"2.2 Fragment Shader",id:"22-fragment-shader",level:3},{value:"2.3 Variable Types",id:"23-variable-types",level:3},{value:"3. LAB 3.1: Solid Color Cube + Rotation",id:"3-lab-31-solid-color-cube--rotation",level:2},{value:"4. LAB 3.2: Lambert + Cell Shading",id:"4-lab-32-lambert--cell-shading",level:2},{value:"5. LAB 3.3: Creative Shader Ideas",id:"5-lab-33-creative-shader-ideas",level:2},{value:"6. Lighting Models in Shaders",id:"6-lighting-models-in-shaders",level:2},{value:"6.1 Lambert (Per-Vertex)",id:"61-lambert-per-vertex",level:3},{value:"6.2 Phong (Per-Pixel)",id:"62-phong-per-pixel",level:3},{value:"7. Exam Question Patterns",id:"7-exam-question-patterns",level:2}];function d(e){const n={blockquote:"blockquote",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"opengl-programmable-pipeline",children:"OpenGL Programmable Pipeline"})}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Covers Section 10 + Lab 3 (WebGL 2.0)"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Focus"}),": Programmable Pipeline vs Fixed-Function, Shader Basics, Lab 3 Extensions",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Exam Ready"}),": Detailed Lab 3.1\u20133.3 solutions + exam-style questions",(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.strong,{children:"Tip"}),": Exam may test shader conversions, lighting models, or creative effects"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"1-programmable-pipeline-overview-section-10",children:"1. Programmable Pipeline Overview (Section 10)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fixed-Function Pipeline"}),": Hard-coded stages (e.g., OpenGL 1.1 with ",(0,i.jsx)(n.code,{children:"glLight"}),", ",(0,i.jsx)(n.code,{children:"glMaterial"}),"). Limited flexibility."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Programmable Pipeline"}),": Custom shaders (GLSL) control vertex and fragment processing. Used in modern WebGL/GLES."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Key Stages"}),":","\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Vertex Shader"}),": Transforms vertices (position, normal, color)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Fragment Shader"}),": Colors pixels (lighting, texturing)."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"2-shader-basics",children:"2. Shader Basics"}),"\n",(0,i.jsx)(n.h3,{id:"21-vertex-shader",children:"2.1 Vertex Shader"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Processes each vertex."}),"\n",(0,i.jsxs)(n.li,{children:["Outputs: Transformed position (",(0,i.jsx)(n.code,{children:"gl_Position"}),"), varying data (e.g., color, normal)."]}),"\n",(0,i.jsx)(n.li,{children:"Example:"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"attribute vec3 a_position;\nattribute vec3 a_normal;\nuniform mat4 u_modelview;\nuniform mat4 u_projection;\nvarying vec3 v_normal;\n\nvoid main() {\n    gl_Position = u_projection * u_modelview * vec4(a_position, 1.0);\n    v_normal = a_normal;  // Pass to fragment\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"22-fragment-shader",children:"2.2 Fragment Shader"}),"\n",(0,i.jsx)(n.p,{children:"Colors each pixel.\nInputs: Varying data from vertex shader.\nExample:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"precision mediump float;\nvarying vec3 v_normal;\nvoid main() {\n    gl_FragColor = vec4(abs(v_normal), 1.0);  // Normal-based color\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"23-variable-types",children:"2.3 Variable Types"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Attribute"}),": Per-vertex data (e.g., ",(0,i.jsx)(n.code,{children:"a_position"}),", ",(0,i.jsx)(n.code,{children:"a_color"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Uniform"}),": Global data (e.g., ",(0,i.jsx)(n.code,{children:"u_modelview"}),", ",(0,i.jsx)(n.code,{children:"u_lightPos"}),")."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Varying"}),": Interpolated data between vertex and fragment (e.g., ",(0,i.jsx)(n.code,{children:"v_normal"}),")."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"3-lab-31-solid-color-cube--rotation",children:"3. LAB 3.1: Solid Color Cube + Rotation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Vertex Shader"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"attribute vec3 a_position;\nuniform mat4 u_modelview;\nuniform mat4 u_projection;\n\nvoid main() {\n    gl_Position = u_projection * u_modelview * vec4(a_position, 1.0);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fragment Shader"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"precision mediump float;\nvoid main() {\n    gl_FragColor = vec4(0.4, 0.7, 1.0, 1.0);  // Solid sky blue\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"JS Implementation"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const canvas = document.getElementById('webgl-canvas');\nconst gl = canvas.getContext('webgl');\n\ngl.enable(gl.DEPTH_TEST);\n\n// Buffers\nconst vertBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);\n\nconst indexBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\ngl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);\n\n// Shader Program\nconst program = createProgram(gl, vertexShaderSource, fragmentShaderSource);\ngl.useProgram(program);\n\n// Attributes\nconst posLoc = gl.getAttribLocation(program, 'a_position');\ngl.enableVertexAttribArray(posLoc);\ngl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);\ngl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);\n\n// Matrices\nlet modelview = mat4.create();\nlet projection = mat4.create();\nmat4.perspective(projection, Math.PI/4, 1, 0.1, 100);\ngl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_projection'), false, projection);\n\n// Animation\nlet angle = 0;\nfunction render() {\n    angle += 0.01;\n    mat4.identity(modelview);\n    mat4.translate(modelview, modelview, [0, 0, -5]);\n    mat4.rotateY(modelview, modelview, angle);\n\n    gl.uniformMatrix4fv(gl.getUniformLocation(program, 'u_modelview'), false, modelview);\n    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT, 0);\n    requestAnimationFrame(render);\n}\nrender();\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"4-lab-32-lambert--cell-shading",children:"4. LAB 3.2: Lambert + Cell Shading"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Add Color Buffer"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"const colorBuffer = gl.createBuffer();\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\ngl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);\n\nconst colorLoc = gl.getAttribLocation(program, 'a_color');\ngl.enableVertexAttribArray(colorLoc);\ngl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);\ngl.vertexAttribPointer(colorLoc, 3, gl.FLOAT, false, 0, 0);\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Vertex Shader"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"attribute vec3 a_position;\nattribute vec3 a_normal;\nattribute vec3 a_color;\nuniform mat4 u_modelview;\nuniform mat4 u_projection;\nuniform mat4 u_normalMatrix;\nvarying vec3 v_normal;\nvarying vec3 v_position;\nvarying vec3 v_color;\n\nvoid main() {\n    vec4 pos = u_modelview * vec4(a_position, 1.0);\n    v_position = pos.xyz;\n    v_normal = normalize((u_normalMatrix * vec4(a_normal, 0.0)).xyz);\n    v_color = a_color;\n    gl_Position = u_projection * pos;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fragment Shader (Lambert + Cell)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"precision mediump float;\nvarying vec3 v_normal;\nvarying vec3 v_position;\nvarying vec3 v_color;\nuniform vec3 u_lightPos;\n\nvoid main() {\n    vec3 L = normalize(u_lightPos - v_position);\n    float NdotL = max(0.0, dot(v_normal, L));\n\n    // Cell shading: 4 levels\n    float levels = 4.0;\n    float shade = floor(NdotL * levels) / (levels - 1.0);  // Adjusted for range\n\n    vec3 finalColor = v_color * shade;\n    gl_FragColor = vec4(finalColor, 1.0);\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"JS: Normal Matrix & Light"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let normalMatrix = mat3.create();\nmat3.normalFromMat4(normalMatrix, modelview);\ngl.uniformMatrix3fv(gl.getUniformLocation(program, 'u_normalMatrix'), false, normalMatrix);\n\nconst lightPos = [5, 5, 5];\ngl.uniform3fv(gl.getUniformLocation(program, 'u_lightPos'), lightPos);\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"5-lab-33-creative-shader-ideas",children:"5. LAB 3.3: Creative Shader Ideas"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Vertex Shader (Wobble Example)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"attribute vec3 a_position;\nuniform mat4 u_modelview;\nuniform mat4 u_projection;\nuniform float u_time;\nvarying vec3 v_pos;\n\nvoid main() {\n    vec3 pos = a_position;\n    pos.y += sin(u_time + pos.x * 10.0) * 0.1;  // Wobble\n    gl_Position = u_projection * u_modelview * vec4(pos, 1.0);\n    v_pos = pos;\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Fragment Shader (Hologram Effect)"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"precision mediump float;\nvarying vec3 v_pos;\nuniform float u_time;\n\nvoid main() {\n    float flicker = sin(u_time * 10.0) * 0.1 + 0.9;\n    float scan = sin(v_pos.y * 20.0 + u_time * 5.0) * 0.1 + 0.5;\n    gl_FragColor = vec4(0.1, 0.8, 1.0, 0.3 * flicker * scan);  // Blue hologram\n}\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"JS: Add Time Uniform"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"let time = 0;\nfunction render() {\n    time += 0.01;\n    gl.uniform1f(gl.getUniformLocation(program, 'u_time'), time);\n    // ... rest of render loop\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"6-lighting-models-in-shaders",children:"6. Lighting Models in Shaders"}),"\n",(0,i.jsx)(n.h3,{id:"61-lambert-per-vertex",children:"6.1 Lambert (Per-Vertex)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"varying vec3 v_normal;\nvarying vec3 v_position;\nuniform vec3 u_lightPos;\n\nvoid main() {\n    vec3 L = normalize(u_lightPos - v_position);\n    float diff = max(0.0, dot(v_normal, L));\n    gl_FragColor = vec4(vec3(1.0, 0.5, 0.2) * diff, 1.0);  // Orange diffuse\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"62-phong-per-pixel",children:"6.2 Phong (Per-Pixel)"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"varying vec3 v_normal;\nvarying vec3 v_position;\nuniform vec3 u_lightPos;\nuniform float u_shininess;\n\nvoid main() {\n    vec3 N = normalize(v_normal);\n    vec3 L = normalize(u_lightPos - v_position);\n    vec3 V = normalize(-v_position);  // To viewer\n    vec3 R = reflect(-L, N);\n    float diff = max(0.0, dot(N, L));\n    float spec = pow(max(0.0, dot(R, V)), u_shininess);\n    vec3 color = vec3(0.8, 0.4, 0.2) * diff + vec3(1.0) * spec * 0.5;\n    gl_FragColor = vec4(color, 1.0);\n}\n"})}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"7-exam-question-patterns",children:"7. Exam Question Patterns"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type 1: Shader Conversion"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.em,{children:'"Convert this OpenGL lighting to WebGL"'})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"OpenGL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-c",children:"glLightfv(GL_LIGHT0, GL_POSITION, {5,5,5,1});\nglMaterialfv(GL_FRONT, GL_DIFFUSE, {1,0,0,1});\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"WebGL:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"// Vertex\nvarying vec3 v_pos, v_normal;\nvoid main() {\n    v_pos = (u_modelview * vec4(a_position, 1.0)).xyz;\n    v_normal = normalize((u_normalMatrix * vec4(a_normal, 0.0)).xyz);\n    gl_Position = u_projection * vec4(v_pos, 1.0);\n}\n\n// Fragment\nuniform vec3 u_lightPos;\nvoid main() {\n    vec3 L = normalize(u_lightPos - v_pos);\n    float diff = max(0.0, dot(v_normal, L));\n    gl_FragColor = vec4(vec3(1,0,0) * diff, 1.0);\n}\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type 2: Add Effect"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.em,{children:'"Add cell shading to this shader"'})]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-glsl",children:"float levels = 4.0;\nfloat shade = floor(diff * levels) / (levels - 1.0);\ngl_FragColor = vec4(v_color * shade, 1.0);\n"})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Type 3: Debug Shader"}),(0,i.jsx)(n.br,{}),"\n",(0,i.jsx)(n.em,{children:'"Fix this code"'})]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Wrong:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"gl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);  // No buffer bind\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.strong,{children:"Correct:"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-js",children:"gl.bindBuffer(gl.ARRAY_BUFFER, vertBuffer);\ngl.vertexAttribPointer(posLoc, 3, gl.FLOAT, false, 0, 0);\n"})})]})}function g(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>s});var l=r(6540);const i={},o=l.createContext(i);function a(e){const n=l.useContext(o);return l.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),l.createElement(o.Provider,{value:n},e.children)}}}]);